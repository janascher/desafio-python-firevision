{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"In\u00edcio","text":"<p>\ud83d\udd25 FireVision \u00e9 uma aplica\u00e7\u00e3o que consiste em utilizar t\u00e9cnicas de vis\u00e3o computacional para detectar inc\u00eandios em imagens e v\u00eddeos. A ideia \u00e9 que o sistema possa identificar a presen\u00e7a de chamas ou fogo em uma cena.</p> <p>Para desenvolver essa aplica\u00e7\u00e3o, foi utilizado t\u00e9cnicas de processamento de imagens, bem como, utilizados algoritmos de detec\u00e7\u00e3o de objetos e segmenta\u00e7\u00e3o de imagem para identificar as \u00e1reas com chamas ou fogo e classificar a cena como uma situa\u00e7\u00e3o de risco.</p> <p>A aplica\u00e7\u00e3o poder\u00e1 ser utilizada em diversas situa\u00e7\u00f5es, como monitoramento de \u00e1reas florestais, detec\u00e7\u00e3o de inc\u00eandios em edif\u00edcios e instala\u00e7\u00f5es industriais, entre outras. A detec\u00e7\u00e3o precoce de inc\u00eandios \u00e9 essencial para evitar danos materiais e prevenir perdas humanas, tornando essa aplica\u00e7\u00e3o muito importante para a seguran\u00e7a p\u00fablica e privada.</p>"},{"location":"diret%C3%B3rio%20firevision/app/","title":"Arquivo app.py","text":"<p>O <code>app.py</code> \u00e9 uma aplica\u00e7\u00e3o gr\u00e1fica baseada na biblioteca PyQt5 que permite selecionar um arquivo de imagem ou v\u00eddeo e executar a detec\u00e7\u00e3o de objetos nele. O algoritmo de detec\u00e7\u00e3o de objetos utilizado \u00e9 o YOLOv5, que \u00e9 executado por meio da chamada do arquivo <code>detect.py</code> na pasta <code>yolov5</code>.</p> <p>A aplica\u00e7\u00e3o gr\u00e1fica apresenta uma barra de progresso e duas labels que s\u00e3o atualizadas durante a execu\u00e7\u00e3o do processo. A primeira label informa o nome do arquivo selecionado e a segunda informa quando a imagem \u00e9 detectada com sucesso. O c\u00f3digo tamb\u00e9m inclui fun\u00e7\u00f5es que realizam a c\u00f3pia do arquivo selecionado para a pasta de entrada do algoritmo de detec\u00e7\u00e3o de objetos, a jun\u00e7\u00e3o dos arquivos de sa\u00edda do YOLOv5 (caso o processamento tenha gerado arquivos divididos), bem como a fun\u00e7\u00e3o de iniciar o processo de detec\u00e7\u00e3o.</p> Bibliotecas necess\u00e1rias <ul> <li><code>sys</code> para acessar vari\u00e1veis e fun\u00e7\u00f5es espec\u00edficas do sistema;</li> <li><code>os</code> para interagir com o sistema operacional;</li> <li><code>shutil</code> para integrar com o sistema operacional (por exemplo, criar e manipular arquivos e pastas);</li> <li><code>PyQt5</code> para criar janelas e widgets. <code>QApplication</code> \u00e9 a classe principal para gerenciar a aplica\u00e7\u00e3o; <code>QWidget</code> \u00e9 a classe base para todos os widgets em PyQt5; <code>QFileDialog</code> \u00e9 usada para abrir caixas de di\u00e1logo para selecionar arquivos e pastas; <code>QPushButton</code> \u00e9 um bot\u00e3o que pode ser clicado para executar uma a\u00e7\u00e3o; <code>QProgressBar</code> \u00e9 uma barra de progresso que mostra o progresso de uma tarefa; <code>QLabel</code> \u00e9 um r\u00f3tulo que pode exibir texto e imagens;</li> <li><code>PyQt5.QtGui</code> importa a classe <code>QPixmap</code> do PyQt5, que \u00e9 usada para carregar imagens.</li> </ul>"},{"location":"diret%C3%B3rio%20firevision/app/#firevision.app.App","title":"<code>App</code>","text":"<p>         Bases: <code>QWidget</code></p> <p>A classe <code>App</code> \u00e9 uma subclasse da classe <code>QWidget</code> e \u00e9 respons\u00e1vel por construir a interface gr\u00e1fica do usu\u00e1rio para o programa FireVision 0.1.0.</p> Source code in <code>firevision/app.py</code> <pre><code>class App(QWidget):\n\"\"\"\n        A classe `App` \u00e9 uma subclasse da classe `QWidget` e \u00e9 respons\u00e1vel por construir a interface gr\u00e1fica do usu\u00e1rio para o programa FireVision 0.1.0.\n    \"\"\"\n\n    def __init__(self):\n\"\"\"\n            O m\u00e9todo `__init__()` \u00e9 um m\u00e9todo especial que \u00e9 executado quando um objeto da classe `App` \u00e9 criado. Neste caso, ele define as dimens\u00f5es da janela e chama o m\u00e9todo `LoadWindow()` para criar a interface gr\u00e1fica.\n        \"\"\"\n        super().__init__()\n        self.title = \"FireVision 0.1.0\"\n        self.left = 220\n        self.top = 220\n        self.width = 640\n        self.height = 480\n        self.LoadWindow()\n\n    def LoadWindow(self):\n\"\"\"\n            O m\u00e9todo `LoadWindow()` define a janela, incluindo o t\u00edtulo, dimens\u00f5es e widgets. Ele cria um bot\u00e3o \"Selecionar Arquivo\" e uma barra de progresso que ser\u00e3o usados posteriormente.\n        \"\"\"\n        self.setWindowTitle(self.title)\n        self.setGeometry(self.left, self.top, self.width, self.height)\n\n        self.step = 0\n        self.progress = QProgressBar(self)\n        self.progress.setGeometry(200, 250, 250, 20)\n\n        button = QPushButton(\"Selecionar Arquivo\", self)\n\n        button.setToolTip(\"Clique para selecionar um arquivo\")\n        button.move(200, 150)\n        button.clicked.connect(self.OpenFileDialog)\n\n        self.pixmap = QPixmap('fogo.jpeg')\n        self.label2 = QLabel('', self)\n        self.label2.setStyleSheet('color: blue; font-size: 12px')\n        self.label2.move(200, 180)\n\n        self.label = QLabel('', self)\n        self.label.setStyleSheet('color: green; font-size: 16px')\n        self.label.move(200, 300)\n\n        self.show()\n\n    def join_files(self, input_filename, output_filename):\n\"\"\"\n            O m\u00e9todo `join_files()` recebe dois par\u00e2metros: `input_filename` e `output_filename`. Ele \u00e9 respons\u00e1vel por juntar os arquivos de sa\u00edda gerados pelo modelo de detec\u00e7\u00e3o de objeto YOLOv5 em um \u00fanico arquivo. Esse m\u00e9todo \u00e9 chamado pelo m\u00e9todo `OpenFileDialog()`.\n        \"\"\"\n        with open(output_filename, 'wb') as f:\n            i = 0\n            while True:\n                chunk_filename = f'{input_filename}.{i}'\n                if os.path.exists(chunk_filename):\n                    with open(chunk_filename, 'rb') as chunk_file:\n                        chunk = chunk_file.read()\n                        f.write(chunk)\n                    i += 1\n                else:\n                    break\n\n        print(\n            f'Os arquivos {input_filename}.* foram juntados em {output_filename}')\n\n    def start_process(self):\n\"\"\"\n            O m\u00e9todo `start_process()` \u00e9 respons\u00e1vel por definir a barra de progresso com um valor m\u00e1ximo de 100 e atualizar o valor da barra de progresso enquanto o programa est\u00e1 executando.\n        \"\"\"\n        self.progress.setMaximum(100)\n\n        while self.progress_value &lt; 100:\n            self.progress_value += 1\n            self.progress.setValue(self.progress_value)\n            QApplication.processEvents()\n\n    def progressLoad(self):\n\"\"\"\n            O m\u00e9todo `progressLoad()` \u00e9 respons\u00e1vel por atualizar o valor da barra de progresso.\n        \"\"\"\n        self.step += 20\n        self.progress.setValue(self.step)\n\n    def setLabel(self):\n\"\"\"\n            O m\u00e9todo `setLabel()` define o texto de uma label da interface gr\u00e1fica como \"Imagem detectada com sucesso\".\n        \"\"\"\n        self.label.setText(\"Imagem detectada com sucesso\")\n\n    # def setSelectText(self):\n    #     # self.pixmap = QPixmap(\"caminho_da_imagem.png\")\n    #     self.label2.setText(\"../teste/fogo.jpg\")\n\n    def OpenFileDialog(self):\n\"\"\"\n            O m\u00e9todo `OpenFileDialog()` \u00e9 chamado quando o bot\u00e3o \"Selecionar Arquivo\" \u00e9 clicado. Ele usa o m\u00e9todo `join_files()` para juntar os arquivos de sa\u00edda gerados pelo modelo YOLOv5. Em seguida, ele abre um di\u00e1logo de sele\u00e7\u00e3o de arquivo para que o usu\u00e1rio possa escolher um arquivo de imagem. Ele atualiza a barra de progresso usando o m\u00e9todo `progressLoad()` e copia o arquivo selecionado para uma pasta espec\u00edfica. Ele, ent\u00e3o, executa o modelo YOLOv5 no arquivo de imagem selecionado usando o m\u00e9todo `os.system()`. Finalmente, ele atualiza a barra de progresso novamente e define o texto de uma label para indicar que a imagem foi detectada com sucesso.\n        \"\"\"\n        self.join_files(\"../yolov5/best.pt\", \"../yolov5/best.pt\")\n\n        filename, _ = QFileDialog.getOpenFileName(\n            self, \"Selecionar Arquivo\", \"\", \"Arquivos de Imagem (*.jpg *jpeg);;Arquivos de V\u00eddeo (.mp4)\")\n\n        if filename:\n            ex.progressLoad()\n            data_folder = os.path.join(\"..\", \"yolov5\", \"data\")\n            images_folder = os.path.join(data_folder, \"images\")\n\n            if not os.path.exists(images_folder):\n                os.makedirs(images_folder)\n            new_filename = os.path.join(\n                images_folder, os.path.basename(filename))\n\n            string = str(new_filename)\n            self.label2.setText(string)\n\n            shutil.copy2(filename, new_filename)\n            ex.progressLoad()\n            print(f\"C\u00f3pia do arquivo salvo em {new_filename}\")\n\n        try:\n            # Muda de diret\u00f3rio\n            os.chdir(\"../yolov5\")\n            ex.progressLoad()\n            ex.progressLoad()\n            # Executa um comando no terminal\n            os.system(\"python detect.py --source data/images --weights best.pt\")\n            ex.progressLoad()\n            # Executa o script \"detect.py\" indicando o caminho runs/train/exp2/weights/best.pt:\n            # os.system(\"python detect.py --source data/images --weights runs/train/exp2/weights/best.pt\")\n            # ex.start_process()\n            ex.setLabel()\n\n        except Exception as e:\n            #print(f\"Erro ao salvar arquivo: {e}\")\n            print(f\"O arquivo foi criado na pasta images do yolov, por\u00e9m no windows pode apresentar o erro: {e}\")\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/app/#firevision.app.App.LoadWindow","title":"<code>LoadWindow()</code>","text":"<p>O m\u00e9todo <code>LoadWindow()</code> define a janela, incluindo o t\u00edtulo, dimens\u00f5es e widgets. Ele cria um bot\u00e3o \"Selecionar Arquivo\" e uma barra de progresso que ser\u00e3o usados posteriormente.</p> Source code in <code>firevision/app.py</code> <pre><code>def LoadWindow(self):\n\"\"\"\n        O m\u00e9todo `LoadWindow()` define a janela, incluindo o t\u00edtulo, dimens\u00f5es e widgets. Ele cria um bot\u00e3o \"Selecionar Arquivo\" e uma barra de progresso que ser\u00e3o usados posteriormente.\n    \"\"\"\n    self.setWindowTitle(self.title)\n    self.setGeometry(self.left, self.top, self.width, self.height)\n\n    self.step = 0\n    self.progress = QProgressBar(self)\n    self.progress.setGeometry(200, 250, 250, 20)\n\n    button = QPushButton(\"Selecionar Arquivo\", self)\n\n    button.setToolTip(\"Clique para selecionar um arquivo\")\n    button.move(200, 150)\n    button.clicked.connect(self.OpenFileDialog)\n\n    self.pixmap = QPixmap('fogo.jpeg')\n    self.label2 = QLabel('', self)\n    self.label2.setStyleSheet('color: blue; font-size: 12px')\n    self.label2.move(200, 180)\n\n    self.label = QLabel('', self)\n    self.label.setStyleSheet('color: green; font-size: 16px')\n    self.label.move(200, 300)\n\n    self.show()\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/app/#firevision.app.App.OpenFileDialog","title":"<code>OpenFileDialog()</code>","text":"<p>O m\u00e9todo <code>OpenFileDialog()</code> \u00e9 chamado quando o bot\u00e3o \"Selecionar Arquivo\" \u00e9 clicado. Ele usa o m\u00e9todo <code>join_files()</code> para juntar os arquivos de sa\u00edda gerados pelo modelo YOLOv5. Em seguida, ele abre um di\u00e1logo de sele\u00e7\u00e3o de arquivo para que o usu\u00e1rio possa escolher um arquivo de imagem. Ele atualiza a barra de progresso usando o m\u00e9todo <code>progressLoad()</code> e copia o arquivo selecionado para uma pasta espec\u00edfica. Ele, ent\u00e3o, executa o modelo YOLOv5 no arquivo de imagem selecionado usando o m\u00e9todo <code>os.system()</code>. Finalmente, ele atualiza a barra de progresso novamente e define o texto de uma label para indicar que a imagem foi detectada com sucesso.</p> Source code in <code>firevision/app.py</code> <pre><code>def OpenFileDialog(self):\n\"\"\"\n        O m\u00e9todo `OpenFileDialog()` \u00e9 chamado quando o bot\u00e3o \"Selecionar Arquivo\" \u00e9 clicado. Ele usa o m\u00e9todo `join_files()` para juntar os arquivos de sa\u00edda gerados pelo modelo YOLOv5. Em seguida, ele abre um di\u00e1logo de sele\u00e7\u00e3o de arquivo para que o usu\u00e1rio possa escolher um arquivo de imagem. Ele atualiza a barra de progresso usando o m\u00e9todo `progressLoad()` e copia o arquivo selecionado para uma pasta espec\u00edfica. Ele, ent\u00e3o, executa o modelo YOLOv5 no arquivo de imagem selecionado usando o m\u00e9todo `os.system()`. Finalmente, ele atualiza a barra de progresso novamente e define o texto de uma label para indicar que a imagem foi detectada com sucesso.\n    \"\"\"\n    self.join_files(\"../yolov5/best.pt\", \"../yolov5/best.pt\")\n\n    filename, _ = QFileDialog.getOpenFileName(\n        self, \"Selecionar Arquivo\", \"\", \"Arquivos de Imagem (*.jpg *jpeg);;Arquivos de V\u00eddeo (.mp4)\")\n\n    if filename:\n        ex.progressLoad()\n        data_folder = os.path.join(\"..\", \"yolov5\", \"data\")\n        images_folder = os.path.join(data_folder, \"images\")\n\n        if not os.path.exists(images_folder):\n            os.makedirs(images_folder)\n        new_filename = os.path.join(\n            images_folder, os.path.basename(filename))\n\n        string = str(new_filename)\n        self.label2.setText(string)\n\n        shutil.copy2(filename, new_filename)\n        ex.progressLoad()\n        print(f\"C\u00f3pia do arquivo salvo em {new_filename}\")\n\n    try:\n        # Muda de diret\u00f3rio\n        os.chdir(\"../yolov5\")\n        ex.progressLoad()\n        ex.progressLoad()\n        # Executa um comando no terminal\n        os.system(\"python detect.py --source data/images --weights best.pt\")\n        ex.progressLoad()\n        # Executa o script \"detect.py\" indicando o caminho runs/train/exp2/weights/best.pt:\n        # os.system(\"python detect.py --source data/images --weights runs/train/exp2/weights/best.pt\")\n        # ex.start_process()\n        ex.setLabel()\n\n    except Exception as e:\n        #print(f\"Erro ao salvar arquivo: {e}\")\n        print(f\"O arquivo foi criado na pasta images do yolov, por\u00e9m no windows pode apresentar o erro: {e}\")\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/app/#firevision.app.App.__init__","title":"<code>__init__()</code>","text":"<p>O m\u00e9todo <code>__init__()</code> \u00e9 um m\u00e9todo especial que \u00e9 executado quando um objeto da classe <code>App</code> \u00e9 criado. Neste caso, ele define as dimens\u00f5es da janela e chama o m\u00e9todo <code>LoadWindow()</code> para criar a interface gr\u00e1fica.</p> Source code in <code>firevision/app.py</code> <pre><code>def __init__(self):\n\"\"\"\n        O m\u00e9todo `__init__()` \u00e9 um m\u00e9todo especial que \u00e9 executado quando um objeto da classe `App` \u00e9 criado. Neste caso, ele define as dimens\u00f5es da janela e chama o m\u00e9todo `LoadWindow()` para criar a interface gr\u00e1fica.\n    \"\"\"\n    super().__init__()\n    self.title = \"FireVision 0.1.0\"\n    self.left = 220\n    self.top = 220\n    self.width = 640\n    self.height = 480\n    self.LoadWindow()\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/app/#firevision.app.App.join_files","title":"<code>join_files(input_filename, output_filename)</code>","text":"<p>O m\u00e9todo <code>join_files()</code> recebe dois par\u00e2metros: <code>input_filename</code> e <code>output_filename</code>. Ele \u00e9 respons\u00e1vel por juntar os arquivos de sa\u00edda gerados pelo modelo de detec\u00e7\u00e3o de objeto YOLOv5 em um \u00fanico arquivo. Esse m\u00e9todo \u00e9 chamado pelo m\u00e9todo <code>OpenFileDialog()</code>.</p> Source code in <code>firevision/app.py</code> <pre><code>def join_files(self, input_filename, output_filename):\n\"\"\"\n        O m\u00e9todo `join_files()` recebe dois par\u00e2metros: `input_filename` e `output_filename`. Ele \u00e9 respons\u00e1vel por juntar os arquivos de sa\u00edda gerados pelo modelo de detec\u00e7\u00e3o de objeto YOLOv5 em um \u00fanico arquivo. Esse m\u00e9todo \u00e9 chamado pelo m\u00e9todo `OpenFileDialog()`.\n    \"\"\"\n    with open(output_filename, 'wb') as f:\n        i = 0\n        while True:\n            chunk_filename = f'{input_filename}.{i}'\n            if os.path.exists(chunk_filename):\n                with open(chunk_filename, 'rb') as chunk_file:\n                    chunk = chunk_file.read()\n                    f.write(chunk)\n                i += 1\n            else:\n                break\n\n    print(\n        f'Os arquivos {input_filename}.* foram juntados em {output_filename}')\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/app/#firevision.app.App.progressLoad","title":"<code>progressLoad()</code>","text":"<p>O m\u00e9todo <code>progressLoad()</code> \u00e9 respons\u00e1vel por atualizar o valor da barra de progresso.</p> Source code in <code>firevision/app.py</code> <pre><code>def progressLoad(self):\n\"\"\"\n        O m\u00e9todo `progressLoad()` \u00e9 respons\u00e1vel por atualizar o valor da barra de progresso.\n    \"\"\"\n    self.step += 20\n    self.progress.setValue(self.step)\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/app/#firevision.app.App.setLabel","title":"<code>setLabel()</code>","text":"<p>O m\u00e9todo <code>setLabel()</code> define o texto de uma label da interface gr\u00e1fica como \"Imagem detectada com sucesso\".</p> Source code in <code>firevision/app.py</code> <pre><code>def setLabel(self):\n\"\"\"\n        O m\u00e9todo `setLabel()` define o texto de uma label da interface gr\u00e1fica como \"Imagem detectada com sucesso\".\n    \"\"\"\n    self.label.setText(\"Imagem detectada com sucesso\")\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/app/#firevision.app.App.start_process","title":"<code>start_process()</code>","text":"<p>O m\u00e9todo <code>start_process()</code> \u00e9 respons\u00e1vel por definir a barra de progresso com um valor m\u00e1ximo de 100 e atualizar o valor da barra de progresso enquanto o programa est\u00e1 executando.</p> Source code in <code>firevision/app.py</code> <pre><code>def start_process(self):\n\"\"\"\n        O m\u00e9todo `start_process()` \u00e9 respons\u00e1vel por definir a barra de progresso com um valor m\u00e1ximo de 100 e atualizar o valor da barra de progresso enquanto o programa est\u00e1 executando.\n    \"\"\"\n    self.progress.setMaximum(100)\n\n    while self.progress_value &lt; 100:\n        self.progress_value += 1\n        self.progress.setValue(self.progress_value)\n        QApplication.processEvents()\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/","title":"Arquivo main.py","text":"<p>O <code>main.py</code> \u00e9 um script Python que l\u00ea arquivos de anota\u00e7\u00e3o no formato Pascal VOC (Visual Object Classes) e converte essas anota\u00e7\u00f5es em arquivos de texto no formato YOLO (You Only Look Once), que \u00e9 um formato popular para treinamento de modelos de detec\u00e7\u00e3o de objetos em imagens.</p> <p>O script l\u00ea arquivos de anota\u00e7\u00e3o xml e, para cada anota\u00e7\u00e3o, extrai informa\u00e7\u00f5es sobre as caixas delimitadoras dos objetos na imagem, bem como os r\u00f3tulos desses objetos. Ele ent\u00e3o converte essas informa\u00e7\u00f5es em um formato YOLO compat\u00edvel e grava um arquivo de texto correspondente. Al\u00e9m disso, ele cria um arquivo de texto com a lista de classes presentes nas anota\u00e7\u00f5es, que \u00e9 \u00fatil para treinar modelos de detec\u00e7\u00e3o de objetos.</p> <p>O c\u00f3digo depende de algumas bibliotecas Python, incluindo <code>os</code>, <code>xml.etree.ElementTree</code>, <code>lxml</code>, <code>cv2</code> e <code>glob</code>. Al\u00e9m disso, ele usa algumas vari\u00e1veis globais, como o caminho para os arquivos de anota\u00e7\u00e3o XML, o caminho para as imagens, o caminho de sa\u00edda para os arquivos de texto e o formato das imagens. O c\u00f3digo tamb\u00e9m lida com a leitura de um arquivo de texto opcional que lista as classes presentes nas anota\u00e7\u00f5es.</p> Bibliotecas necess\u00e1rias <ul> <li><code>os</code> para interagir com o sistema operacional;</li> <li><code>xml.etree.ElementTree</code> para ler e analisar arquivos XML;</li> <li><code>lxml.etree</code> para processar e analisar XMLs de forma mais eficiente;</li> <li><code>cv2</code> para manipular imagens usando OpenCV;</li> <li><code>glob</code> para encontrar arquivos em um diret\u00f3rio.</li> <li><code>typing</code> fornece recursos para trabalhar com tipos de dados, anota\u00e7\u00f5es de tipo e gera\u00e7\u00e3o de classes gen\u00e9ricas.</li> </ul>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.PascalVocConverter","title":"<code>PascalVocConverter</code>","text":"<p>A classe <code>PascalVocConverter</code> converte anota\u00e7\u00f5es de objetos em imagens do formato Pascal VOC para um formato de anota\u00e7\u00e3o de detec\u00e7\u00e3o de objetos diferente. Para isso, a classe recebe o caminho dos arquivos xml com as anota\u00e7\u00f5es, o caminho das imagens correspondentes, o caminho de sa\u00edda para os arquivos de anota\u00e7\u00e3o convertidos, um arquivo de texto com a lista de classes e uma extens\u00e3o de arquivo (default \".jpg\").</p> Source code in <code>firevision/main.py</code> <pre><code>class PascalVocConverter:\n\"\"\"\n        A classe `PascalVocConverter` converte anota\u00e7\u00f5es de objetos em imagens do formato Pascal VOC para um formato de anota\u00e7\u00e3o de detec\u00e7\u00e3o de objetos diferente. Para isso, a classe recebe o caminho dos arquivos xml com as anota\u00e7\u00f5es, o caminho das imagens correspondentes, o caminho de sa\u00edda para os arquivos de anota\u00e7\u00e3o convertidos, um arquivo de texto com a lista de classes e uma extens\u00e3o de arquivo (default \".jpg\").\n    \"\"\"\n\n    def __init__(self, parentpath, addxmlpath, addimgpath, outputpath, classes_txt, ext=\".jpg\"):\n\"\"\"\n            O m\u00e9todo `__init__()` \u00e9 o construtor da classe e inicializa o objeto com os caminhos dos diret\u00f3rios dos arquivos XML, das imagens, a pasta de sa\u00edda para salvar os arquivos txt gerados, um arquivo de texto que cont\u00e9m os nomes das classes e uma extens\u00e3o padr\u00e3o .jpg.\n        \"\"\"\n        self.parentpath = parentpath\n        self.addxmlpath = addxmlpath\n        self.addimgpath = addimgpath\n        self.outputpath = outputpath\n        self.classes_txt = classes_txt\n        self.classes = dict()\n        self.num_classes = 0\n        self.ext = ext\n\n    def run(self):\n\"\"\"\n            O m\u00e9todo `run()` realiza a convers\u00e3o para o novo formato de anota\u00e7\u00e3o e grava os resultados em arquivos de texto separados. Cada arquivo de anota\u00e7\u00e3o de detec\u00e7\u00e3o de objeto possui uma linha para cada objeto anotado, indicando a classe do objeto e as coordenadas normalizadas do ret\u00e2ngulo delimitador que cont\u00e9m o objeto na imagem. Al\u00e9m disso, a classe cria um arquivo de texto classes.txt contendo a lista de todas as classes detectadas nas anota\u00e7\u00f5es de entrada.\n        \"\"\"\n\n        if os.path.isfile(self.classes_txt):\n            with open(self.classes_txt, \"r\") as f:\n                class_list = f.read().strip().split()\n                self.classes = {k: v for (v, k) in enumerate(class_list)}\n\n        xmlPaths = glob(self.addxmlpath + \"/*.xml\")\n\n        for xmlPath in xmlPaths:\n            tVocParseReader = PascalVocReader(xmlPath)\n            shapes = tVocParseReader.getShapes()\n\n            with open(self.outputpath + \"/\" + os.path.basename(xmlPath)[:-4] + \".txt\", \"w\") as f:\n                for shape in shapes:\n                    class_name = shape[0]\n                    box = shape[1]\n                    filename = os.path.splitext(\n                        self.addimgpath + \"/\" + os.path.basename(xmlPath)[:-4])[0] + self.ext\n\n                    if class_name not in self.classes.keys():\n                        self.classes[class_name] = self.num_classes\n                        self.num_classes += 1\n                    class_idx = self.classes[class_name]\n\n                    (height, width, _) = cv2.imread(filename).shape\n\n                    coord_min = box[0]\n                    coord_max = box[2]\n\n                    xcen = float((coord_min[0] + coord_max[0])) / 2 / width\n                    ycen = float((coord_min[1] + coord_max[1])) / 2 / height\n                    w = float((coord_max[0] - coord_min[0])) / width\n                    h = float((coord_max[1] - coord_min[1])) / height\n\n                    f.write(\"%d %.06f %.06f %.06f %.06f\\n\" %\n                            (class_idx, xcen, ycen, w, h))\n                    print(class_idx, xcen, ycen, w, h)\n\n        with open(self.parentpath + \"classes.txt\", \"w\") as f:\n            for key in self.classes.keys():\n                f.write(\"%s\\n\" % key)\n                print(key)\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.PascalVocConverter.__init__","title":"<code>__init__(parentpath, addxmlpath, addimgpath, outputpath, classes_txt, ext='.jpg')</code>","text":"<p>O m\u00e9todo <code>__init__()</code> \u00e9 o construtor da classe e inicializa o objeto com os caminhos dos diret\u00f3rios dos arquivos XML, das imagens, a pasta de sa\u00edda para salvar os arquivos txt gerados, um arquivo de texto que cont\u00e9m os nomes das classes e uma extens\u00e3o padr\u00e3o .jpg.</p> Source code in <code>firevision/main.py</code> <pre><code>def __init__(self, parentpath, addxmlpath, addimgpath, outputpath, classes_txt, ext=\".jpg\"):\n\"\"\"\n        O m\u00e9todo `__init__()` \u00e9 o construtor da classe e inicializa o objeto com os caminhos dos diret\u00f3rios dos arquivos XML, das imagens, a pasta de sa\u00edda para salvar os arquivos txt gerados, um arquivo de texto que cont\u00e9m os nomes das classes e uma extens\u00e3o padr\u00e3o .jpg.\n    \"\"\"\n    self.parentpath = parentpath\n    self.addxmlpath = addxmlpath\n    self.addimgpath = addimgpath\n    self.outputpath = outputpath\n    self.classes_txt = classes_txt\n    self.classes = dict()\n    self.num_classes = 0\n    self.ext = ext\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.PascalVocConverter.run","title":"<code>run()</code>","text":"<p>O m\u00e9todo <code>run()</code> realiza a convers\u00e3o para o novo formato de anota\u00e7\u00e3o e grava os resultados em arquivos de texto separados. Cada arquivo de anota\u00e7\u00e3o de detec\u00e7\u00e3o de objeto possui uma linha para cada objeto anotado, indicando a classe do objeto e as coordenadas normalizadas do ret\u00e2ngulo delimitador que cont\u00e9m o objeto na imagem. Al\u00e9m disso, a classe cria um arquivo de texto classes.txt contendo a lista de todas as classes detectadas nas anota\u00e7\u00f5es de entrada.</p> Source code in <code>firevision/main.py</code> <pre><code>def run(self):\n\"\"\"\n        O m\u00e9todo `run()` realiza a convers\u00e3o para o novo formato de anota\u00e7\u00e3o e grava os resultados em arquivos de texto separados. Cada arquivo de anota\u00e7\u00e3o de detec\u00e7\u00e3o de objeto possui uma linha para cada objeto anotado, indicando a classe do objeto e as coordenadas normalizadas do ret\u00e2ngulo delimitador que cont\u00e9m o objeto na imagem. Al\u00e9m disso, a classe cria um arquivo de texto classes.txt contendo a lista de todas as classes detectadas nas anota\u00e7\u00f5es de entrada.\n    \"\"\"\n\n    if os.path.isfile(self.classes_txt):\n        with open(self.classes_txt, \"r\") as f:\n            class_list = f.read().strip().split()\n            self.classes = {k: v for (v, k) in enumerate(class_list)}\n\n    xmlPaths = glob(self.addxmlpath + \"/*.xml\")\n\n    for xmlPath in xmlPaths:\n        tVocParseReader = PascalVocReader(xmlPath)\n        shapes = tVocParseReader.getShapes()\n\n        with open(self.outputpath + \"/\" + os.path.basename(xmlPath)[:-4] + \".txt\", \"w\") as f:\n            for shape in shapes:\n                class_name = shape[0]\n                box = shape[1]\n                filename = os.path.splitext(\n                    self.addimgpath + \"/\" + os.path.basename(xmlPath)[:-4])[0] + self.ext\n\n                if class_name not in self.classes.keys():\n                    self.classes[class_name] = self.num_classes\n                    self.num_classes += 1\n                class_idx = self.classes[class_name]\n\n                (height, width, _) = cv2.imread(filename).shape\n\n                coord_min = box[0]\n                coord_max = box[2]\n\n                xcen = float((coord_min[0] + coord_max[0])) / 2 / width\n                ycen = float((coord_min[1] + coord_max[1])) / 2 / height\n                w = float((coord_max[0] - coord_min[0])) / width\n                h = float((coord_max[1] - coord_min[1])) / height\n\n                f.write(\"%d %.06f %.06f %.06f %.06f\\n\" %\n                        (class_idx, xcen, ycen, w, h))\n                print(class_idx, xcen, ycen, w, h)\n\n    with open(self.parentpath + \"classes.txt\", \"w\") as f:\n        for key in self.classes.keys():\n            f.write(\"%s\\n\" % key)\n            print(key)\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.PascalVocReader","title":"<code>PascalVocReader</code>","text":"<p>A classe <code>PascalVocReader</code> \u00e9 respons\u00e1vel pela leitura de arquivos no formato Pascal VOC.</p> Source code in <code>firevision/main.py</code> <pre><code>class PascalVocReader:\n\"\"\"\n        A classe `PascalVocReader` \u00e9 respons\u00e1vel pela leitura de arquivos no formato Pascal VOC.\n    \"\"\"\n\n    def __init__(self, filepath):\n\"\"\"\n            O m\u00e9todo `__init__()` \u00e9 o construtor da classe e inicializa as vari\u00e1veis necess\u00e1rias, como a lista de formas (`shapes`), o caminho do arquivo (`filepath`) e uma vari\u00e1vel booleana para verificar se o arquivo foi verificado (verified). Tamb\u00e9m chama a fun\u00e7\u00e3o `parseXML()` para fazer a an\u00e1lise do arquivo xml.\n        \"\"\"\n        self.shapes = []\n        self.filepath = filepath\n        self.verified = False\n\n        try:\n            self.parseXML()\n        except:\n            pass\n\n    def getShapes(self):\n\"\"\"\n            O m\u00e9todo `getShapes()` retorna a lista de formas (`shapes`) encontradas no arquivo xml.\n        \"\"\"\n        return self.shapes\n\n    def addShape(self, label, bndbox, filename, difficult):\n\"\"\"\n            O m\u00e9todo `addShape()` \u00e9 respons\u00e1vel por extrair informa\u00e7\u00f5es sobre uma forma, como r\u00f3tulo (`label`), coordenadas do ret\u00e2ngulo delimitador (`bndbox`), nome do arquivo (`filename`) e se a forma \u00e9 dif\u00edcil de ser detectada (`difficult`), e adicion\u00e1-las \u00e0 lista de formas. A partir das coordenadas do ret\u00e2ngulo delimitador, o m\u00e9todo calcula os pontos dos quatro v\u00e9rtices do ret\u00e2ngulo e adiciona-os \u00e0 lista de formas.\n        \"\"\"\n        xmin = int(bndbox.find(\"xmin\").text)\n        ymin = int(bndbox.find(\"ymin\").text)\n        xmax = int(bndbox.find(\"xmax\").text)\n        ymax = int(bndbox.find(\"ymax\").text)\n        points = [(xmin, ymin), (xmax, ymin), (xmax, ymax), (xmin, ymax)]\n        self.shapes.append((label, points, filename, difficult))\n\n    def parseXML(self):\n\"\"\"\n            O m\u00e9todo `parseXML()` \u00e9 respons\u00e1vel por analisar o arquivo XML e extrair informa\u00e7\u00f5es sobre cada objeto (anota\u00e7\u00e3o de objeto) encontrado no arquivo. Ele usa a biblioteca `ElementTree` para analisar o arquivo XML e extrair o caminho da imagem e a vari\u00e1vel de verifica\u00e7\u00e3o. Em seguida, itera sobre cada objeto encontrado no arquivo, extrai informa\u00e7\u00f5es sobre a forma e chama o m\u00e9todo addShape para adicion\u00e1-la \u00e0 lista de formas.\n        \"\"\"\n        assert self.filepath.endswith(XML_EXT), \"Unsupport file format\"\n        parser = etree.XMLParser(encoding=ENCODE_METHOD)\n        xmltree = ElementTree.parse(self.filepath, parser=parser).getroot()\n        path = xmltree.find(\"path\").text\n\n        try:\n            verified = xmltree.attrib[\"verified\"]\n            if verified == \"yes\":\n                self.verified = True\n        except KeyError:\n            self.verified = False\n\n        for object_iter in xmltree.findall(\"object\"):\n            bndbox = object_iter.find(\"bndbox\")\n            label = object_iter.find(\"name\").text\n\n            difficult = False\n            if object_iter.find(\"difficult\") is not None:\n                difficult = bool(int(object_iter.find(\"difficult\").text))\n            self.addShape(label, bndbox, path, difficult)\n        return True\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.PascalVocReader.__init__","title":"<code>__init__(filepath)</code>","text":"<p>O m\u00e9todo <code>__init__()</code> \u00e9 o construtor da classe e inicializa as vari\u00e1veis necess\u00e1rias, como a lista de formas (<code>shapes</code>), o caminho do arquivo (<code>filepath</code>) e uma vari\u00e1vel booleana para verificar se o arquivo foi verificado (verified). Tamb\u00e9m chama a fun\u00e7\u00e3o <code>parseXML()</code> para fazer a an\u00e1lise do arquivo xml.</p> Source code in <code>firevision/main.py</code> <pre><code>def __init__(self, filepath):\n\"\"\"\n        O m\u00e9todo `__init__()` \u00e9 o construtor da classe e inicializa as vari\u00e1veis necess\u00e1rias, como a lista de formas (`shapes`), o caminho do arquivo (`filepath`) e uma vari\u00e1vel booleana para verificar se o arquivo foi verificado (verified). Tamb\u00e9m chama a fun\u00e7\u00e3o `parseXML()` para fazer a an\u00e1lise do arquivo xml.\n    \"\"\"\n    self.shapes = []\n    self.filepath = filepath\n    self.verified = False\n\n    try:\n        self.parseXML()\n    except:\n        pass\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.PascalVocReader.addShape","title":"<code>addShape(label, bndbox, filename, difficult)</code>","text":"<p>O m\u00e9todo <code>addShape()</code> \u00e9 respons\u00e1vel por extrair informa\u00e7\u00f5es sobre uma forma, como r\u00f3tulo (<code>label</code>), coordenadas do ret\u00e2ngulo delimitador (<code>bndbox</code>), nome do arquivo (<code>filename</code>) e se a forma \u00e9 dif\u00edcil de ser detectada (<code>difficult</code>), e adicion\u00e1-las \u00e0 lista de formas. A partir das coordenadas do ret\u00e2ngulo delimitador, o m\u00e9todo calcula os pontos dos quatro v\u00e9rtices do ret\u00e2ngulo e adiciona-os \u00e0 lista de formas.</p> Source code in <code>firevision/main.py</code> <pre><code>def addShape(self, label, bndbox, filename, difficult):\n\"\"\"\n        O m\u00e9todo `addShape()` \u00e9 respons\u00e1vel por extrair informa\u00e7\u00f5es sobre uma forma, como r\u00f3tulo (`label`), coordenadas do ret\u00e2ngulo delimitador (`bndbox`), nome do arquivo (`filename`) e se a forma \u00e9 dif\u00edcil de ser detectada (`difficult`), e adicion\u00e1-las \u00e0 lista de formas. A partir das coordenadas do ret\u00e2ngulo delimitador, o m\u00e9todo calcula os pontos dos quatro v\u00e9rtices do ret\u00e2ngulo e adiciona-os \u00e0 lista de formas.\n    \"\"\"\n    xmin = int(bndbox.find(\"xmin\").text)\n    ymin = int(bndbox.find(\"ymin\").text)\n    xmax = int(bndbox.find(\"xmax\").text)\n    ymax = int(bndbox.find(\"ymax\").text)\n    points = [(xmin, ymin), (xmax, ymin), (xmax, ymax), (xmin, ymax)]\n    self.shapes.append((label, points, filename, difficult))\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.PascalVocReader.getShapes","title":"<code>getShapes()</code>","text":"<p>O m\u00e9todo <code>getShapes()</code> retorna a lista de formas (<code>shapes</code>) encontradas no arquivo xml.</p> Source code in <code>firevision/main.py</code> <pre><code>def getShapes(self):\n\"\"\"\n        O m\u00e9todo `getShapes()` retorna a lista de formas (`shapes`) encontradas no arquivo xml.\n    \"\"\"\n    return self.shapes\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.PascalVocReader.parseXML","title":"<code>parseXML()</code>","text":"<p>O m\u00e9todo <code>parseXML()</code> \u00e9 respons\u00e1vel por analisar o arquivo XML e extrair informa\u00e7\u00f5es sobre cada objeto (anota\u00e7\u00e3o de objeto) encontrado no arquivo. Ele usa a biblioteca <code>ElementTree</code> para analisar o arquivo XML e extrair o caminho da imagem e a vari\u00e1vel de verifica\u00e7\u00e3o. Em seguida, itera sobre cada objeto encontrado no arquivo, extrai informa\u00e7\u00f5es sobre a forma e chama o m\u00e9todo addShape para adicion\u00e1-la \u00e0 lista de formas.</p> Source code in <code>firevision/main.py</code> <pre><code>def parseXML(self):\n\"\"\"\n        O m\u00e9todo `parseXML()` \u00e9 respons\u00e1vel por analisar o arquivo XML e extrair informa\u00e7\u00f5es sobre cada objeto (anota\u00e7\u00e3o de objeto) encontrado no arquivo. Ele usa a biblioteca `ElementTree` para analisar o arquivo XML e extrair o caminho da imagem e a vari\u00e1vel de verifica\u00e7\u00e3o. Em seguida, itera sobre cada objeto encontrado no arquivo, extrai informa\u00e7\u00f5es sobre a forma e chama o m\u00e9todo addShape para adicion\u00e1-la \u00e0 lista de formas.\n    \"\"\"\n    assert self.filepath.endswith(XML_EXT), \"Unsupport file format\"\n    parser = etree.XMLParser(encoding=ENCODE_METHOD)\n    xmltree = ElementTree.parse(self.filepath, parser=parser).getroot()\n    path = xmltree.find(\"path\").text\n\n    try:\n        verified = xmltree.attrib[\"verified\"]\n        if verified == \"yes\":\n            self.verified = True\n    except KeyError:\n        self.verified = False\n\n    for object_iter in xmltree.findall(\"object\"):\n        bndbox = object_iter.find(\"bndbox\")\n        label = object_iter.find(\"name\").text\n\n        difficult = False\n        if object_iter.find(\"difficult\") is not None:\n            difficult = bool(int(object_iter.find(\"difficult\").text))\n        self.addShape(label, bndbox, path, difficult)\n    return True\n</code></pre>"},{"location":"diret%C3%B3rio%20firevision/firevision/#firevision.main.main","title":"<code>main()</code>","text":"<p>A fun\u00e7\u00e3o <code>main()</code> \u00e9 o construtor da classe e inicializa o objeto com o caminho do arquivo xml a ser lido e cria algumas vari\u00e1veis como uma lista vazia de formas (<code>shapes</code>) encontradas no arquivo, o caminho do arquivo e uma vari\u00e1vel de verifica\u00e7\u00e3o de integridade do arquivo.</p> Source code in <code>firevision/main.py</code> <pre><code>def main():\n\"\"\"\n        A fun\u00e7\u00e3o `main()` \u00e9 o construtor da classe e inicializa o objeto com o caminho do arquivo xml a ser lido e cria algumas vari\u00e1veis como uma lista vazia de formas (`shapes`) encontradas no arquivo, o caminho do arquivo e uma vari\u00e1vel de verifica\u00e7\u00e3o de integridade do arquivo.\n    \"\"\"\n    parent_path = \"./\"\n    addxmlpath = parent_path + \"data/training/annotations\"\n    addimgpath = parent_path + \"data/training/images\"\n    output_path = parent_path + \"labels\"\n    classes_txt = \"./fire_classes.txt\"\n\n    converter = PascalVocConverter(\n        parent_path, addxmlpath, addimgpath, output_path, classes_txt)\n    converter.run()\n</code></pre>"},{"location":"diret%C3%B3rio%20yolov5/","title":"Sobre YOLOv5","text":"<p>YOLOv5 \u00e9 uma rede neural de detec\u00e7\u00e3o de objetos de \u00faltima gera\u00e7\u00e3o desenvolvida pela Ultralytics. YOLO significa \"You Only Look Once\", o que se refere ao fato de que a rede avalia a imagem inteira de uma vez s\u00f3 para detectar objetos, ao contr\u00e1rio de outras abordagens que dividem a imagem em partes menores. O modelo YOLOv5 tem v\u00e1rios aprimoramentos em rela\u00e7\u00e3o \u00e0s vers\u00f5es anteriores, como o uso de uma arquitetura mais leve e eficiente e o aumento do tamanho do conjunto de dados de treinamento.</p> <p>A detec\u00e7\u00e3o de objetos \u00e9 uma tarefa cr\u00edtica em muitas aplica\u00e7\u00f5es de vis\u00e3o computacional, como vigil\u00e2ncia, condu\u00e7\u00e3o aut\u00f4noma, reconhecimento de faces, entre outras. YOLOv5 \u00e9 uma ferramenta poderosa para lidar com essa tarefa, pois permite detectar e classificar objetos em tempo real em uma variedade de cen\u00e1rios. \u00c9 amplamente utilizado em v\u00e1rios setores, incluindo com\u00e9rcio eletr\u00f4nico, publicidade, seguran\u00e7a e transporte.</p>"},{"location":"diret%C3%B3rio%20yolov5/#armazenamento-da-imagem-selecionada-para-deteccao-de-fogo","title":"Armazenamento da imagem selecionada para detec\u00e7\u00e3o de fogo","text":"<p>A imagem ou v\u00eddeo do usu\u00e1rio ficam salvas na pasta \"images\" dentro da pasta \"data\" do diret\u00f3rio \"../yolov5\".</p> <p>Exemplo de imagem a ser detectada:</p>"},{"location":"diret%C3%B3rio%20yolov5/#armazenamento-da-imagem-com-fogo-detectado","title":"Armazenamento da imagem com fogo detectado","text":"<p>A imagem ou v\u00eddeo do usu\u00e1rio detectados ficam salvas na pasta \"runs\" dentro da pasta \"detect\" do diret\u00f3rio \"../yolov5\".</p> <p>Exemplo de imagem com o fogo detectado:</p>"},{"location":"mkdocs/","title":"Sobre MkDocs","text":"<p>Para acessar a documenta\u00e7\u00e3o completa, visite mkdocs.org.</p>"},{"location":"mkdocs/#comandos","title":"Comandos","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Cria um novo projeto.</li> <li><code>mkdocs serve</code> - Inicia o servidor de documenta\u00e7\u00e3o em tempo real.</li> <li><code>mkdocs build</code> - Constr\u00f3i o site de documenta\u00e7\u00e3o.</li> <li><code>mkdocs -h</code> - Exibe a mensagem de ajuda e sai.</li> </ul>"},{"location":"mkdocs/#organizacao-do-projeto","title":"Organiza\u00e7\u00e3o do projeto","text":"<pre><code>mkdocs.yml    # O arquivo de configura\u00e7\u00e3o.\ndocs/\n    index.md  # A p\u00e1gina inicial da documenta\u00e7\u00e3o.\n    ...       # Outras p\u00e1ginas em markdown, imagens e outros arquivos.\n</code></pre>"}]}